# -*- coding: utf-8 -*-
"""Quantum-Machine-Learning-Hybrid-Algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pKYgrwW1BbCxeOcU-7lO2w31ebT7-_yO
"""

### quantum_ml.ipynb
```python
# Quantum Machine Learning Implementation
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification, make_circles
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Qiskit imports
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit.circuit import Parameter
from qiskit.primitives import Sampler
from qiskit_aer import Aer
from qiskit.quantum_info import SparsePauliOp
from qiskit_algorithms.optimizers import COBYLA, SPSA
import warnings
warnings.filterwarnings('ignore')

print("Quantum Machine Learning Implementation")
print("=" * 50)

# Generate quantum-suitable dataset
def generate_quantum_dataset(n_samples=200):
    X, y = make_circles(n_samples=n_samples, noise=0.1, factor=0.6, random_state=42)
    # Scale to [0, 2π] for quantum encoding
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_quantum = (X_scaled + 2) * np.pi / 4  # Scale to [0, π]
    return X_quantum, y, scaler

# Quantum Feature Map
def create_feature_map(n_qubits, n_features):
    qc = QuantumCircuit(n_qubits)

    # Parameters for data encoding
    feature_params = [Parameter(f'x[{i}]') for i in range(n_features)]

    # ZZ Feature Map
    for i in range(n_qubits):
        qc.h(i)
        if i < n_features:
            qc.rz(feature_params[i], i)

    # Entangling gates
    for i in range(n_qubits - 1):
        qc.cx(i, i + 1)
        if i < n_features - 1:
            qc.rz(feature_params[i] * feature_params[i + 1], i + 1)

    return qc, feature_params

# Variational Ansatz
def create_ansatz(n_qubits, n_layers):
    qc = QuantumCircuit(n_qubits)

    # Parameters for variational gates
    params = []

    for layer in range(n_layers):
        # Rotation gates
        layer_params = []
        for qubit in range(n_qubits):
            theta = Parameter(f'θ_{layer}_{qubit}_x')
            phi = Parameter(f'θ_{layer}_{qubit}_y')
            lam = Parameter(f'θ_{layer}_{qubit}_z')

            qc.rx(theta, qubit)
            qc.ry(phi, qubit)
            qc.rz(lam, qubit)

            layer_params.extend([theta, phi, lam])

        params.extend(layer_params)

        # Entangling gates
        for qubit in range(n_qubits - 1):
            qc.cx(qubit, qubit + 1)

        # Circular entanglement
        if n_qubits > 2:
            qc.cx(n_qubits - 1, 0)

    return qc, params

# Quantum Neural Network
class QuantumNeuralNetwork:
    def __init__(self, n_qubits=4, n_layers=2):
        self.n_qubits = n_qubits
        self.n_layers = n_layers
        self.n_features = 2  # For 2D dataset

        # Create quantum circuits
        self.feature_map, self.feature_params = create_feature_map(n_qubits, self.n_features)
        self.ansatz, self.ansatz_params = create_ansatz(n_qubits, n_layers)

        # Combine circuits
        self.circuit = QuantumCircuit(n_qubits, 1)
        self.circuit = self.circuit.compose(self.feature_map)
        self.circuit = self.circuit.compose(self.ansatz)

        # Measurement
        self.circuit.measure(0, 0)

        # Initialize parameters
        self.parameters = np.random.random(len(self.ansatz_params)) * 2 * np.pi

        # Quantum backend
        self.backend = Aer.get_backend('qasm_simulator')

    def forward(self, X, parameters):
        predictions = []

        for x in X:
            # Bind feature parameters
            param_dict = {self.feature_params[i]: x[i] for i in range(len(x))}
            # Bind ansatz parameters
            param_dict.update({self.ansatz_params[i]: parameters[i] for i in range(len(parameters))})

            # Create bound circuit
            bound_circuit = self.circuit.bind_parameters(param_dict)

            # Execute circuit
            job = self.backend.run(bound_circuit, shots=1024)
            result = job.result()
            counts = result.get_counts()

            # Calculate expectation value
            prob_0 = counts.get('0', 0) / 1024
            prob_1 = counts.get('1', 0) / 1024
            expectation = prob_0 - prob_1  # Map to [-1, 1]

            predictions.append(1 if expectation > 0 else 0)

        return np.array(predictions)

    def cost_function(self, parameters, X, y):
        predictions = self.forward(X, parameters)
        # Binary cross-entropy loss
        cost = np.mean((predictions - y) ** 2)
        return cost

    def train(self, X_train, y_train, max_iter=100):
        print("Training Quantum Neural Network...")

        # Use classical optimizer
        optimizer = COBYLA(maxiter=max_iter)

        costs = []

        def callback(x):
            cost = self.cost_function(x, X_train, y_train)
            costs.append(cost)
            if len(costs) % 10 == 0:
                print(f"Iteration {len(costs)}: Cost = {cost:.4f}")

        # Optimize parameters
        result = optimizer.minimize(
            fun=lambda params: self.cost_function(params, X_train, y_train),
            x0=self.parameters,
            callback=callback
        )

        self.parameters = result.x
        self.training_costs = costs

        print(f"Training completed. Final cost: {costs[-1]:.4f}")

    def predict(self, X):
        return self.forward(X, self.parameters)

# Classical Neural Network for comparison
from sklearn.neural_network import MLPClassifier

# Generate dataset
print("Generating quantum-suitable dataset...")
X, y, scaler = generate_quantum_dataset(n_samples=200)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

print(f"Training set size: {len(X_train)}")
print(f"Test set size: {len(X_test)}")

# Train Quantum Neural Network
qnn = QuantumNeuralNetwork(n_qubits=4, n_layers=2)
qnn.train(X_train, y_train, max_iter=50)

# Train Classical Neural Network
classical_nn = MLPClassifier(hidden_layer_sizes=(10, 5), max_iter=1000, random_state=42)
classical_nn.fit(X_train, y_train)

# Make predictions
print("\nMaking predictions...")
y_pred_quantum = qnn.predict(X_test)
y_pred_classical = classical_nn.predict(X_test)

# Evaluate models
quantum_accuracy = accuracy_score(y_test, y_pred_quantum)
classical_accuracy = accuracy_score(y_test, y_pred_classical)

print(f"\nModel Performance:")
print(f"Quantum NN Accuracy: {quantum_accuracy:.4f}")
print(f"Classical NN Accuracy: {classical_accuracy:.4f}")

print("\nQuantum NN Classification Report:")
print(classification_report(y_test, y_pred_quantum))

# Visualization
fig, axes = plt.subplots(2, 2, figsize=(15, 12))

# Original dataset
axes[0, 0].scatter(X[:, 0], X[:, 1], c=y, cmap='viridis', alpha=0.7)
axes[0, 0].set_title('Original Dataset')
axes[0, 0].set_xlabel('Feature 1')
axes[0, 0].set_ylabel('Feature 2')

# Training cost
axes[0, 1].plot(qnn.training_costs)
axes[0, 1].set_title('Quantum NN Training Cost')
axes[0, 1].set_xlabel('Iteration')
axes[0, 1].set_ylabel('Cost')
axes[0, 1].grid(True, alpha=0.3)

# Quantum predictions
axes[1, 0].scatter(X_test[:, 0], X_test[:, 1], c=y_pred_quantum, cmap='viridis', alpha=0.7)
axes[1, 0].set_title(f'Quantum NN Predictions (Acc: {quantum_accuracy:.3f})')
axes[1, 0].set_xlabel('Feature 1')
axes[1, 0].set_ylabel('Feature 2')

# Classical predictions
axes[1, 1].scatter(X_test[:, 0], X_test[:, 1], c=y_pred_classical, cmap='viridis', alpha=0.7)
axes[1, 1].set_title(f'Classical NN Predictions (Acc: {classical_accuracy:.3f})')
axes[1, 1].set_xlabel('Feature 1')
axes[1, 1].set_ylabel('Feature 2')

plt.tight_layout()
plt.show()

# Quantum Advantage Analysis
print("\n=== Quantum Advantage Analysis ===")
print("Potential advantages of Quantum ML:")
print("1. Exponential state space for complex patterns")
print("2. Natural handling of superposition and entanglement")
print("3. Quantum interference for feature interactions")
print("4. Possible speedup for certain problem types")

print(f"\nCircuit Properties:")
print(f"Number of qubits: {qnn.n_qubits}")
print(f"Number of layers: {qnn.n_layers}")
print(f"Number of parameters: {len(qnn.parameters)}")

# Circuit visualization
print("\nQuantum Circuit Structure:")
print(qnn.circuit.draw(output='text'))

print("Quantum Machine Learning Implementation Complete!")